<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <title>worker</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body>
</body>
<script src="benchmark/benchmark.js"></script>
<script src="index.js"></script>
<script>
    const socket = io(`http://${window.location.hostname}:8080/worker`);

    let score;
    let latency;
    BenchmarkModule().then(benchmark => {
        const t0 = performance.now();
        benchmark.ccall("benchmark");
        const t1 = performance.now();
        score = (1 / (t1 - t0).toFixed(2)).toFixed(4) * 1000;

        socket.on("connect", () => {
            const pingStart = performance.now();

            socket.emit("ping_resultSocket");

            socket.on("pong_resultSocket", () => {
                latency = (performance.now() - pingStart).toFixed(2);

                const workerInfo = {
                    system: {
                        platform: navigator.platform,
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        hardwareConcurrency: navigator.hardwareConcurrency,
                        deviceMemory: navigator.deviceMemory || 'unknown'
                    },
                    performance: {
                        benchmarkScore: parseFloat(score),
                        latency: parseFloat(latency)
                    }
                };

                socket.emit("register", workerInfo);
            });
        });
    });
    setInterval(() => {
        if (socket && socket.connected) {
            socket.emit("ping_resultSocket");
        }
    }, 5000);

    function assessTaskComplexity(task) {
        if (task.method === 'montecarlo') {
            return Math.log10(task.samples || 10000);
        } else {
            const a = task.a || 0;
            const b = task.b || 1;
            const dx = task.dx || 0.001;
            const steps = Math.abs((b - a) / dx);
            return Math.log10(steps);
        }
    }
    function calculateProcessingParams(batch) {
        const complexity = assessTaskComplexity(batch[0]);
        console.log(`Złożoność zadania: ${complexity}`);

        // Dla ekstremalnie złożonych zadań (ponad 10^8 kroków)
        if (complexity > 8) {
            return {
                chunkSize: 1,                  // Tylko jedno zadanie na raz
                pauseTime: 200,                // Dłuższa przerwa
                reportEvery: 1,                // Raportuj po każdym zadaniu
                maxExecutionTime: 50,          // Bardzo krótki czas wykonania
                heartbeatInterval: 3000        // Dodatkowy heartbeat co 3 sekundy
            };
        }
        // Dla bardzo złożonych zadań (ponad 10^6 kroków)
        else if (complexity > 6) {
            return {
                chunkSize: 1,
                pauseTime: 150,
                reportEvery: 1,
                maxExecutionTime: 100,        // ms
                heartbeatInterval: 5000
            };
        }
        // Dla złożonych zadań
        else if (complexity > 5) {
            return {
                chunkSize: 1,
                pauseTime: 100,
                reportEvery: 1,
                maxExecutionTime: 150,        // ms
                heartbeatInterval: 10000
            };
        }
        // Dla średnio złożonych zadań
        else if (complexity > 4) {
            return {
                chunkSize: 2,
                pauseTime: 50,
                reportEvery: 2,
                maxExecutionTime: 200,        // ms
                heartbeatInterval: 0         // Wyłącz dodatkowy heartbeat
            };
        }
        // Dla umiarkowanie złożonych zadań
        else if (complexity > 3) {
            const baseChunkSize = Math.max(2, Math.min(10, Math.ceil((score * 20) / latency)));
            return {
                chunkSize: baseChunkSize,
                pauseTime: 20,
                reportEvery: Math.max(2, baseChunkSize),
                maxExecutionTime: 300,        // ms
                heartbeatInterval: 0
            };
        }
        // Dla prostych zadań
        else {
            const baseChunkSize = Math.max(5, Math.min(25, Math.ceil((score * 50) / latency)));
            return {
                chunkSize: baseChunkSize,
                pauseTime: 10,
                reportEvery: Math.max(5, baseChunkSize * 2),
                maxExecutionTime: 500,        // ms
                heartbeatInterval: 0
            };
        }
    }

    Module.onRuntimeInitialized = () => {
        socket.on("task_batch", (batch) => {
            console.log(`Otrzymano paczkę z ${batch.length} zadaniami:`,
                batch[0].method,
                batch[0].method === 'montecarlo' ?
                    `samples: ${batch[0].samples}` :
                    `range: ${batch[0].a}-${batch[0].b}, dx: ${batch[0].dx}`);

            const params = calculateProcessingParams(batch);
            console.log(`Parametry przetwarzania: chunkSize=${params.chunkSize}, pauseTime=${params.pauseTime}ms, maxExecTime=${params.maxExecutionTime}ms`);

            let heartbeatTimer = null;
            if (params.heartbeatInterval > 0) {
                heartbeatTimer = setInterval(() => {
                    socket.emit("ping_resultSocket");
                    console.log("Wysłano heartbeat...");
                }, params.heartbeatInterval);
            }

            processBatchTimeboxed(batch, params).finally(() => {
                if (heartbeatTimer) {
                    clearInterval(heartbeatTimer);
                }
            });
        });

        async function processBatchTimeboxed(batch, params) {
            const method = batch[0].method;
            const clientId = batch[0].clientId;

            let currentIndex = 0;
            let batchSum = 0;
            let taskCount = 0;
            let firstTaskId = batch[0].taskId;
            let totalProcessed = 0;
            const totalTasks = batch.length;
            const safeExecutionTime = params.maxExecutionTime;

            while (currentIndex < batch.length) {
                const startChunkIndex = currentIndex;
                const endIndex = Math.min(currentIndex + params.chunkSize, batch.length);
                const startTime = performance.now();
                let tasksProcessedInThisChunk = 0;
                for (let i = currentIndex; i < endIndex; i++) {
                    try {
                        const data = batch[i];
                        let result;

                        if (data.method === 'montecarlo') {
                            const y_max = Math.min(data.y_max || 1.0, 1.0);
                            const seedOffset = data.seedOffset || 0;
                            result = Module.ccall(
                                "monte_carlo",
                                "number",
                                ["number", "number", "number", "number", "number"],
                                [data.a, data.b, data.samples, y_max, seedOffset]
                            );
                        } else {
                            result = Module.ccall(
                                "add",
                                "number",
                                ["number", "number", "number"],
                                [data.a, data.b, data.dx]
                            );
                        }

                        batchSum += result;
                        taskCount++;
                        tasksProcessedInThisChunk++;
                        totalProcessed++;

                        // Sprawdź, czy nie przekraczamy limitu czasu dla jednego zadania
                        const currentTime = performance.now();
                        if (currentTime - startTime > safeExecutionTime) {
                            break;
                        }
                    } catch (error) {
                        console.error("Błąd przetwarzania zadania:", error);
                        // Kontynuuj mimo błędu
                    }
                }

                // Zaktualizuj indeks na podstawie faktycznie wykonanych zadań
                currentIndex = startChunkIndex + tasksProcessedInThisChunk;

                // Raportuj postęp co 10%
                const progressPercent = Math.floor((totalProcessed / totalTasks) * 100);
                if (progressPercent % 10 === 0) {
                    console.log(`Postęp: ${progressPercent}% (${totalProcessed}/${totalTasks})`);
                }

                // Wysyłaj wyniki odpowiednio często, aby klient wiedział o postępie
                if (taskCount >= params.reportEvery || currentIndex >= batch.length) {
                    try {
                        socket.emit("batch_result", {
                            batchId: firstTaskId,
                            clientId: clientId,
                            result: batchSum,
                            tasksCount: taskCount,
                            method: method,
                            // montecarlo specific
                            a: batch[0].a,
                            b: batch[0].b,
                            y_max: batch[0].y_max
                        });

                        // Resetuj liczniki dla następnej partii
                        batchSum = 0;
                        taskCount = 0;
                        firstTaskId = currentIndex < batch.length ? batch[currentIndex].taskId : null;
                    } catch (error) {
                        console.error("Błąd wysyłania wyników:", error);
                    }
                }

                // Odetchnij - daj przeglądarce szansę na obsługę innych zdarzeń
                // Dłuższa przerwa dla złożonych zadań
                await new Promise(resolve => setTimeout(resolve, params.pauseTime));

                // Dodatkowy heartbeat po każdej paczce dla ekstremalnie złożonych zadań
                if (params.heartbeatInterval > 0) {
                    try {
                        socket.emit("ping_resultSocket");
                    } catch (error) {
                        console.error("Błąd wysyłania heartbeat:", error);
                    }
                }
            }
        }
    };
</script>

</html>