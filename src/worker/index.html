<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <title>worker</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body>
</body>
<script src="benchmark/benchmark.js"></script>
<script src="index.js"></script>
<script>
    const socket = io(`http://${window.location.hostname}:8080/worker`);
    const resultSocket = io(`http://${window.location.hostname}:8090/worker`);

    let score;
    let latency;
    BenchmarkModule().then(benchmark => {
        const t0 = performance.now();
        benchmark.ccall("benchmark");
        const t1 = performance.now();
        score = (1 / (t1 - t0).toFixed(2)).toFixed(4) * 1000;

        socket.on("connect", () => {
            const pingStart = performance.now();

            resultSocket.emit("ping_resultSocket");

            resultSocket.on("pong_resultSocket", () => {
                latency = (performance.now() - pingStart).toFixed(2);

                const workerInfo = {
                    system: {
                        platform: navigator.platform,
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        hardwareConcurrency: navigator.hardwareConcurrency,
                        deviceMemory: navigator.deviceMemory || 'unknown'
                    },
                    performance: {
                        benchmarkScore: parseFloat(score),
                        latency: parseFloat(latency)
                    }
                };

                socket.emit("register", workerInfo);
            });
        });
    });

    Module.onRuntimeInitialized = () => {
        socket.on("task_batch", (batch) => {
            const subBatchSize = Math.max(10, Math.min(
                100,
                Math.ceil((score * 100) / latency)
            ));

            let batchSum = 0;
            let taskCount = 0;
            let firstTaskId = batch[0].taskId;
            let clientId = batch[0].clientId;
            const method = batch[0].method;

            for (let i = 0; i < batch.length; i++) {
                const data = batch[i];
                let result;

                if (data.method === 'montecarlo') {
                    const y_max = Math.min(data.y_max || 1.0, 1.0);
                    const seedOffset = data.seedOffset || 0;
                    result = Module.ccall(
                        "monte_carlo",
                        "number",
                        ["number", "number", "number", "number", "number"],
                        [data.a, data.b, data.samples, y_max, seedOffset]
                    );
                } else {
                    result = Module.ccall(
                        "add",
                        "number",
                        ["number", "number", "number"],
                        [data.a, data.b, data.dx]
                    );
                }

                batchSum += result;
                taskCount++;

                // Send results when we reach the sub-batch size OR when we're at the last task
                if (taskCount >= subBatchSize || i === batch.length - 1) {
                    resultSocket.emit("batch_result", {
                        batchId: firstTaskId,
                        clientId: clientId,
                        result: batchSum,
                        tasksCount: taskCount,
                        method: method,
                        // montecarlo specific
                        a: batch[0].a,
                        b: batch[0].b,
                        y_max: batch[0].y_max
                    });

                    // Reset for next sub-batch
                    batchSum = 0;
                    taskCount = 0;
                    firstTaskId = i < batch.length - 1 ? batch[i + 1].taskId : null;
                }
            }
        });
    };
</script>


</html>