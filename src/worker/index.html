<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <title>worker</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body>
</body>
<script src="benchmark/benchmark.js"></script>
<script src="index.js"></script>
<script>
    const socket = io(`http://${window.location.hostname}:8080/worker`);

    let score;
    let latency;
    BenchmarkModule().then(benchmark => {
        const t0 = performance.now();
        benchmark.ccall("benchmark");
        const t1 = performance.now();
        score = (1 / (t1 - t0).toFixed(2)).toFixed(4) * 1000;

        socket.on("connect", () => {
            const pingStart = performance.now();

            socket.emit("ping_resultSocket");

            socket.on("pong_resultSocket", () => {
                latency = (performance.now() - pingStart).toFixed(2);

                const workerInfo = {
                    system: {
                        platform: navigator.platform,
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        hardwareConcurrency: navigator.hardwareConcurrency,
                        deviceMemory: navigator.deviceMemory || 'unknown'
                    },
                    performance: {
                        benchmarkScore: parseFloat(score),
                        latency: parseFloat(latency)
                    }
                };

                socket.emit("register", workerInfo);
            });
        });
    });

    function getDevicePerformanceRating() {
        const maxExpectedScore = 10;
        const minExpectedScore = 0.1;

        let normalized = (score - minExpectedScore) / (maxExpectedScore - minExpectedScore);
        normalized = Math.max(0, Math.min(1, normalized));
        return normalized;
    }

    function assessTaskComplexity(task) {
        if (task.method === 'montecarlo') {
            return Math.log10(task.samples || 10000);
        } else {
            const a = task.a || 0;
            const b = task.b || 1;
            const dx = task.dx || 0.001;
            const steps = Math.abs((b - a) / dx);
            return Math.log10(steps);
        }
    }

    function calculateProcessingParams(batch) {
        const complexity = assessTaskComplexity(batch[0]);
        const devicePerformance = getDevicePerformanceRating();

        const performanceMultiplier = 0.5 + devicePerformance;

        // przejebane
        if (complexity > 8) {
            return {
                chunkSize: 1,
                pauseTime: Math.round(200 / performanceMultiplier),
                reportEvery: 1,
                maxExecutionTime: Math.round(50 * performanceMultiplier)
            };
        }
        // bardzo ciezkie
        else if (complexity > 6) {
            const adjustedChunkSize = devicePerformance > 0.7 ? 2 : 1;
            return {
                chunkSize: adjustedChunkSize,
                pauseTime: Math.round(150 / performanceMultiplier),
                reportEvery: adjustedChunkSize,
                maxExecutionTime: Math.round(100 * performanceMultiplier)
            };
        }
        // ciezkie
        else if (complexity > 5) {
            const adjustedChunkSize = devicePerformance > 0.5 ? 2 : 1;
            return {
                chunkSize: adjustedChunkSize,
                pauseTime: Math.round(100 / performanceMultiplier),
                reportEvery: adjustedChunkSize,
                maxExecutionTime: Math.round(150 * performanceMultiplier)
            };
        }
        // srednie
        else if (complexity > 4) {
            const adjustedChunkSize = Math.max(2, Math.floor(3 * performanceMultiplier));
            return {
                chunkSize: adjustedChunkSize,
                pauseTime: Math.round(50 / performanceMultiplier),
                reportEvery: adjustedChunkSize,
                maxExecutionTime: Math.round(200 * performanceMultiplier)
            };
        }
        // umiarkoweane
        else if (complexity > 3) {
            const baseChunkSize = Math.max(
                2,
                Math.min(
                    15,
                    Math.ceil((score * 20) / latency * performanceMultiplier)
                )
            );
            return {
                chunkSize: baseChunkSize,
                pauseTime: Math.round(20 / performanceMultiplier),
                reportEvery: Math.max(2, baseChunkSize),
                maxExecutionTime: Math.round(300 * performanceMultiplier)
            };
        }
        else {
            const baseChunkSize = Math.max(
                5,
                Math.min(
                    30,
                    Math.ceil((score * 50) / latency * performanceMultiplier)
                )
            );
            return {
                chunkSize: baseChunkSize,
                pauseTime: Math.round(10 / performanceMultiplier),
                reportEvery: Math.max(5, baseChunkSize * 2),
                maxExecutionTime: Math.round(500 * performanceMultiplier)
            };
        }
    }

    Module.onRuntimeInitialized = () => {
        socket.on("task_batch", (batch) => {
            const testData = batch[0];
            const testStart = performance.now();

            try {
                if (testData.method === 'montecarlo') {
                    Module.ccall(
                        "monte_carlo",
                        "number",
                        ["number", "number", "number", "number", "number"],
                        [testData.a, testData.b, testData.samples, testData.y_max || 1.0, 0]
                    );
                } else {
                    Module.ccall(
                        "add",
                        "number",
                        ["number", "number", "number"],
                        [testData.a, testData.b, testData.dx]
                    );
                }

                const testDuration = performance.now() - testStart;
                console.log(`Test pojedynczego zadania: ${testDuration.toFixed(2)}ms`);

                const params = calculateProcessingParams(batch);

                if (testDuration > 200) {
                    params.chunkSize = Math.max(1, Math.floor(params.chunkSize / 2));
                    params.maxExecutionTime = Math.min(params.maxExecutionTime, testDuration * 2);
                }
                processBatchTimeboxed(batch, params);
            } catch (error) {
                const safeParams = {
                    chunkSize: 1,
                    pauseTime: 200,
                    reportEvery: 1,
                    maxExecutionTime: 50
                };
                processBatchTimeboxed(batch, safeParams);
            }
        });

        async function processBatchTimeboxed(batch, params) {
            const method = batch[0].method;
            const clientId = batch[0].clientId;

            let currentIndex = 0;
            let batchSum = 0;
            let taskCount = 0;
            let firstTaskId = batch[0].taskId;
            let totalProcessed = 0;
            const totalTasks = batch.length;
            const safeExecutionTime = params.maxExecutionTime;

            while (currentIndex < batch.length) {
                const startChunkIndex = currentIndex;
                const endIndex = Math.min(currentIndex + params.chunkSize, batch.length);
                const startTime = performance.now();
                let tasksProcessedInThisChunk = 0;

                for (let i = currentIndex; i < endIndex; i++) {
                    const data = batch[i];
                    let result;

                    if (data.method === 'montecarlo') {
                        const y_max = Math.min(data.y_max || 1.0, 1.0);
                        const seedOffset = data.seedOffset || 0;
                        result = Module.ccall(
                            "monte_carlo",
                            "number",
                            ["number", "number", "number", "number", "number"],
                            [data.a, data.b, data.samples, y_max, seedOffset]
                        );
                    } else {
                        result = Module.ccall(
                            "add",
                            "number",
                            ["number", "number", "number"],
                            [data.a, data.b, data.dx]
                        );
                    }

                    batchSum += result;
                    taskCount++;
                    tasksProcessedInThisChunk++;
                    totalProcessed++;

                    const currentTime = performance.now();
                    // if (currentTime - startTime > safeExecutionTime) {
                    //     console.warn("Przekroczono limit czasu dla zadania:", data.taskId);
                    //     break;
                    // }
                }

                currentIndex = startChunkIndex + tasksProcessedInThisChunk;

                if (taskCount >= params.reportEvery || currentIndex >= batch.length) {
                    try {
                        socket.emit("batch_result", {
                            batchId: firstTaskId,
                            clientId: clientId,
                            result: batchSum,
                            tasksCount: taskCount,
                            method: method,
                            // montecarlo specific
                            a: batch[0].a,
                            b: batch[0].b,
                            y_max: batch[0].y_max
                        });
                        batchSum = 0;
                        taskCount = 0;
                        firstTaskId = currentIndex < batch.length ? batch[currentIndex].taskId : null;
                    } catch (error) {
                        console.error("Błąd wysyłania wyników:", error);
                    }
                }
                await new Promise(resolve => setTimeout(resolve, params.pauseTime));
            }
        }
    };
</script>

</html>