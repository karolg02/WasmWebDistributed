<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <title>worker</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body>
</body>
<script src="benchmark/benchmark.js"></script>
<script src="index.js"></script>
<script>
    const socket = io(`http://${window.location.hostname}:8080/worker`);
    const resultSocket = io(`http://${window.location.hostname}:8090/worker`);

    let score;
    let latency;
    BenchmarkModule().then(benchmark => {
        const t0 = performance.now();
        benchmark.ccall("benchmark");
        const t1 = performance.now();
        score = (1 / (t1 - t0).toFixed(2)).toFixed(4) * 1000;

        socket.on("connect", () => {
            const pingStart = performance.now();

            resultSocket.emit("ping_resultSocket");

            resultSocket.on("pong_resultSocket", () => {
                latency = (performance.now() - pingStart).toFixed(2);

                const workerInfo = {
                    system: {
                        platform: navigator.platform,
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        hardwareConcurrency: navigator.hardwareConcurrency,
                        deviceMemory: navigator.deviceMemory || 'unknown'
                    },
                    performance: {
                        benchmarkScore: parseFloat(score),
                        latency: parseFloat(latency)
                    }
                };

                socket.emit("register", workerInfo);
            });
        });
    });
    
    Module.onRuntimeInitialized = () => {
        socket.on("task_batch", (batch) => {
            const subBatchSize = Math.max(10, Math.min(
                100,
                Math.ceil((score * 100) / latency)
            ));

            let batchSum = 0;
            let taskCount = 0;
            let firstTaskId = batch[0].taskId;
            let clientId = batch[0].clientId;

            // Store the method for the batch
            const method = batch[0].method;

            for (const data of batch) {
                let result;
                
                // Handle different integration methods
                if (data.method === 'montecarlo') {
                    // Force y_max to be 1.0 for sin(x)
                    const y_max = Math.min(data.y_max || 1.0, 1.0);
                    const seedOffset = data.seedOffset || 0;
                    
                    console.log(`Monte Carlo task: Range [${data.a}, ${data.b}], Samples: ${data.samples}, y_max: ${y_max}`);
                    
                    result = Module.ccall(
                        "monte_carlo", 
                        "number", 
                        ["number", "number", "number", "number", "number"], 
                        [data.a, data.b, data.samples, y_max, seedOffset]
                    );
                    
                    console.log(`Monte Carlo result: ${result}`);
                } else {
                    // Original trapezoidal method
                    result = Module.ccall(
                        "add", 
                        "number", 
                        ["number", "number", "number"], 
                        [data.a, data.b, data.dx]
                    );
                }
                
                batchSum += result;
                taskCount++;

                if (taskCount >= subBatchSize || taskCount === batch.length) {
                    resultSocket.emit("batch_result", {
                        batchId: firstTaskId,
                        clientId: clientId,
                        result: batchSum,
                        tasksCount: taskCount,
                        method: method
                    });

                    batchSum = 0;
                    taskCount = 0;
                }
            }
        });
    };
</script>


</html>