<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <title>worker</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body>
</body>
<script src="benchmark/benchmark.js"></script>
<script src="index.js"></script>
<script>
    const socket = io(`http://${window.location.hostname}:8080/worker`);

    let score;
    let latency;
    BenchmarkModule().then(benchmark => {
        const t0 = performance.now();
        benchmark.ccall("benchmark");
        const t1 = performance.now();
        score = (1 / (t1 - t0).toFixed(2)).toFixed(4) * 1000;

        socket.on("connect", () => {
            const pingStart = performance.now();

            socket.emit("ping_resultSocket");

            socket.on("pong_resultSocket", () => {
                latency = (performance.now() - pingStart).toFixed(2);

                const workerInfo = {
                    system: {
                        platform: navigator.platform,
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        hardwareConcurrency: navigator.hardwareConcurrency,
                        deviceMemory: navigator.deviceMemory || 'unknown'
                    },
                    performance: {
                        benchmarkScore: parseFloat(score),
                        latency: parseFloat(latency)
                    }
                };

                socket.emit("register", workerInfo);
            });
        });
    });

    function assessTaskComplexity(task) {
        if (task.method === 'montecarlo') {
            return Math.log10(task.samples || 10000);
        } else {
            const a = task.a || 0;
            const b = task.b || 1;
            const dx = task.dx || 0.001;
            const steps = Math.abs((b - a) / dx);
            return Math.log10(steps);
        }
    }
    function calculateProcessingParams(batch) {
        const complexity = assessTaskComplexity(batch[0]);
        console.log("Złożoność zadania:", complexity);
        // przejebane
        if (complexity > 8) {
            return {
                chunkSize: 1,                  // Tylko jedno zadanie na raz
                pauseTime: 200,                // Dłuższa przerwa
                reportEvery: 1,                // Raportuj po każdym zadaniu
                maxExecutionTime: 50,          // Bardzo krótki czas wykonania
                heartbeatInterval: 3000        // Dodatkowy heartbeat co 3 sekundy
            };
        }
        // bardzo ciezkie
        else if (complexity > 6) {
            return {
                chunkSize: 1,
                pauseTime: 150,
                reportEvery: 1,
                maxExecutionTime: 100,
                heartbeatInterval: 5000
            };
        }
        // ciezkie
        else if (complexity > 5) {
            return {
                chunkSize: 1,
                pauseTime: 100,
                reportEvery: 1,
                maxExecutionTime: 150,
                heartbeatInterval: 10000
            };
        }
        // srednie
        else if (complexity > 4) {
            return {
                chunkSize: 2,
                pauseTime: 50,
                reportEvery: 2,
                maxExecutionTime: 200,
                heartbeatInterval: 0
            };
        }
        // umiarkoweane
        else if (complexity > 3) {
            const baseChunkSize = Math.max(2, Math.min(10, Math.ceil((score * 20) / latency)));
            return {
                chunkSize: baseChunkSize,
                pauseTime: 20,
                reportEvery: Math.max(2, baseChunkSize),
                maxExecutionTime: 300,
                heartbeatInterval: 0
            };
        }
        // proste
        else {
            const baseChunkSize = Math.max(5, Math.min(25, Math.ceil((score * 50) / latency)));
            return {
                chunkSize: baseChunkSize,
                pauseTime: 10,
                reportEvery: Math.max(5, baseChunkSize * 2),
                maxExecutionTime: 500,
                heartbeatInterval: 0
            };
        }
    }

    Module.onRuntimeInitialized = () => {
        socket.on("task_batch", (batch) => {
            const params = calculateProcessingParams(batch);
            processBatchTimeboxed(batch, params);
        });

        async function processBatchTimeboxed(batch, params) {
            const method = batch[0].method;
            const clientId = batch[0].clientId;

            let currentIndex = 0;
            let batchSum = 0;
            let taskCount = 0;
            let firstTaskId = batch[0].taskId;
            let totalProcessed = 0;
            const totalTasks = batch.length;
            const safeExecutionTime = params.maxExecutionTime;

            while (currentIndex < batch.length) {
                const startChunkIndex = currentIndex;
                const endIndex = Math.min(currentIndex + params.chunkSize, batch.length);
                const startTime = performance.now();
                let tasksProcessedInThisChunk = 0;
                for (let i = currentIndex; i < endIndex; i++) {
                    const data = batch[i];
                    let result;

                    if (data.method === 'montecarlo') {
                        const y_max = Math.min(data.y_max || 1.0, 1.0);
                        const seedOffset = data.seedOffset || 0;
                        result = Module.ccall(
                            "monte_carlo",
                            "number",
                            ["number", "number", "number", "number", "number"],
                            [data.a, data.b, data.samples, y_max, seedOffset]
                        );
                    } else {
                        result = Module.ccall(
                            "add",
                            "number",
                            ["number", "number", "number"],
                            [data.a, data.b, data.dx]
                        );
                    }

                    batchSum += result;
                    taskCount++;
                    tasksProcessedInThisChunk++;
                    totalProcessed++;

                    const currentTime = performance.now();
                    if (currentTime - startTime > safeExecutionTime) {
                        console.warn("Przekroczono limit czasu dla zadania:", data.taskId);
                        break;
                    }
                }
                currentIndex = startChunkIndex + tasksProcessedInThisChunk;

                if (taskCount >= params.reportEvery || currentIndex >= batch.length) {
                    try {
                        socket.emit("batch_result", {
                            batchId: firstTaskId,
                            clientId: clientId,
                            result: batchSum,
                            tasksCount: taskCount,
                            method: method,
                            // montecarlo specific
                            a: batch[0].a,
                            b: batch[0].b,
                            y_max: batch[0].y_max
                        });
                        batchSum = 0;
                        taskCount = 0;
                        firstTaskId = currentIndex < batch.length ? batch[currentIndex].taskId : null;
                    } catch (error) {
                        console.error("Błąd wysyłania wyników:", error);
                    }
                }
                await new Promise(resolve => setTimeout(resolve, params.pauseTime));
            }
        }
    };
</script>

</html>