<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <title>Worker Configuration</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 10px;
        }

        #controls,
        #status {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid black;
            border-radius: 5px;
        }

        #status {
            background-color: #cfcaca;
            white-space: pre-line;
        }

        label {
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <h1>Web Worker Configuration</h1>
    <div id="controls" style="font-size: large;">
        <label for="workerCount">Ilu workerów użyć (max: <span id="maxWorkers"></span>):</label>
        <input type="number" id="workerCount" min="1" value="1">
        <button id="initializeButton">Zatwierdź i przeprowadź benchmark</button>
    </div>
    <div id="status">Konsola:</div>

    <script>
        if (window.Worker) {
            const statusDiv = document.getElementById('status');
            const workerCountInput = document.getElementById('workerCount');
            const initializeButton = document.getElementById('initializeButton');
            const maxWorkersSpan = document.getElementById('maxWorkers');
            const maxHardwareConcurrency = navigator.hardwareConcurrency || 1;
            maxWorkersSpan.textContent = maxHardwareConcurrency;
            workerCountInput.max = maxHardwareConcurrency;
            workerCountInput.value = 1;

            let workerPool = [];
            let workersReadyCount = 0;
            let actualNumWorkers = 0;

            const pendingTasks = [];
            let currentClientId = null;
            const STATIC_CHUNK_SIZE = 100;
            const workerBusy = new Map();
            let dispatchIntervalId = null;
            const workerAssignedRemaining = new Map();

            function initWorkerBusy() {
                workerPool.forEach(w => workerBusy.set(w.id, false));
            }

            function computeChunkSize() {
                return Math.min(pendingTasks.length, STATIC_CHUNK_SIZE);
            }

            function dispatchChunks() {
                if (!workerPool || workerPool.length === 0) return;
                for (let i = 0; i < workerPool.length; i++) {
                    const w = workerPool[i];
                    if (workerBusy.get(w.id)) continue;
                    if (pendingTasks.length === 0) break;

                    const chunkSize = Math.min(pendingTasks.length, computeChunkSize());
                    const chunk = pendingTasks.splice(0, chunkSize);
                    if (chunk.length === 0) break;

                        workerBusy.set(w.id, true);
                        workerAssignedRemaining.set(w.id, chunk.length);
                        try {
                            w.postMessage({ type: 'task_batch', data: chunk });
                        } catch (err) {
                            statusDiv.textContent += `\nFailed to postMessage to worker ${w.id}: ${err.message}`;
                            workerBusy.set(w.id, false);
                        }
                }
            }

            let socket;
            let mainLatency;
            let myWorkerId = null;

            initializeButton.onclick = function () {
                actualNumWorkers = parseInt(workerCountInput.value, 10);
                if (isNaN(actualNumWorkers) || actualNumWorkers < 1 || actualNumWorkers > maxHardwareConcurrency) {
                    statusDiv.textContent = `Niepoprawna liczba workerów, wybierz pomiędzy 1-${maxHardwareConcurrency}.`;
                    return;
                }

                initializeButton.disabled = true;
                workerCountInput.disabled = true;

                workerPool.forEach(worker => worker.terminate());
                workerPool = [];
                workersReadyCount = 0;

                for (let i = 0; i < actualNumWorkers; i++) {
                    const worker = new Worker('worker.js');
                    worker.id = i;

                    worker.onmessage = function (e) {
                        const message = e.data;
                        handleWorkerMessage(message, worker.id);
                    };

                    worker.onerror = function (e) {
                        statusDiv.textContent += `\nError od workera: ${worker.id} - ${e.message}`;
                    };
                    workerPool.push(worker);
                }
                initWorkerBusy();

                if (dispatchIntervalId) clearInterval(dispatchIntervalId);
                dispatchIntervalId = setInterval(() => {
                    dispatchChunks();
                }, 200);
            };


            function handleWorkerMessage(message, workerId) {
                switch (message.type) {
                    case 'worker_script_ready':
                        workersReadyCount++;
                        if (workersReadyCount === actualNumWorkers) {
                            initializeMainConnection();
                        }
                        break;
                    case 'benchmark_result':
                        const benchmarkScore = message.error ? 0 : parseFloat(message.score);
                        statusDiv.textContent += `\nTest wydajnościowy zakończony. Wynik: ${benchmarkScore.toFixed(2)}`;

                        const workerInfo = {
                            system: {
                                platform: navigator.platform,
                                userAgent: navigator.userAgent,
                                language: navigator.language,
                                hardwareConcurrency: workerCountInput.value,
                                actualWorkersUsed: actualNumWorkers,
                                deviceMemory: navigator.deviceMemory || 'unknown'
                            },
                            performance: {
                                benchmarkScore: parseFloat(benchmarkScore.toFixed(2)),
                                latency: parseFloat(mainLatency)
                            }
                        };
                        socket.emit("register", workerInfo);
                        statusDiv.textContent += `\nZarejestrowano workerów na serwerze. Czekam na zadania...`;
                        break;
                    case 'batch_progress':
                        const processed = Number(message.data.tasksProcessedInChunk) || 0;
                        const prevRemaining = workerAssignedRemaining.get(workerId) || 0;
                        const newRemaining = Math.max(0, prevRemaining - processed);
                        workerAssignedRemaining.set(workerId, newRemaining);
                        if (newRemaining === 0) {
                            workerBusy.set(workerId, false);
                            dispatchChunks();
                        }
                        const progressDataForServer = {
                            clientId: message.data.clientId,
                            results: message.data.results,
                            tasksCount: message.data.tasksProcessedInChunk,
                            method: message.data.method,
                            a: message.data.a,
                            b: message.data.b,
                        };
                            if (socket && socket.connected) {
                                socket.emit("batch_result", progressDataForServer);
                            } else {
                                statusDiv.textContent += `\nSocket not ready, skipping sending result for ${progressDataForServer.clientId}`;
                            }
                        break;
                    case 'task_error':
                        socket.emit("task_error", message.data);
                        break;
                    case 'worker_error':
                        if (message.data.clientId) {
                            socket.emit("worker_error", { clientId: message.data.clientId, error: message.data.error });
                        }
                        statusDiv.textContent += `\nWorker ${workerId} zarejestrował error: ${message.data.error}`;
                        break;
                    case 'custom_module_loaded':
                        socket.emit("custom_module_loaded", { clientId: message.data.clientId });
                        break;
                }
            }

            function initializeMainConnection() {
                socket = io(`http://${window.location.hostname}:8080/worker`);

                socket.on("connect", () => {
                    myWorkerId = socket.id;
                    statusDiv.textContent += '\nPołączono z serwerem. Mierzenie opóźnienia...';
                    const pingStart = performance.now();
                    socket.emit("ping_resultSocket");

                    socket.on("pong_resultSocket", () => {
                        mainLatency = (performance.now() - pingStart).toFixed(2);
                        statusDiv.textContent += `\nOpóźnienie: ${mainLatency}ms. Rozpoczęcie benchmarku...`;
                        if (workerPool.length > 0) {
                            workerPool[0].postMessage({ type: 'run_benchmark' });
                        }
                    });
                });

                let nextWorkerIndex = 0;

                socket.on("task_batch", (batch) => {
                    if (!batch || batch.length === 0) return;

                    if (batch && batch[0].targetWorkerId) {
                        if (batch[0].targetWorkerId !== myWorkerId) {
                            return;
                        }
                    }
                    const batchClientId = batch[0].clientId;

                    if (!currentClientId) currentClientId = batchClientId;

                    pendingTasks.push(...batch);

                    if (workerBusy.size !== workerPool.length) initWorkerBusy();
                    dispatchChunks();
                });

                socket.on("custom_wasm_available", (data) => {
                    if (data.targetWorkerIds && !data.targetWorkerIds.includes(myWorkerId)) {
                        return;
                    }
                    
                    statusDiv.textContent += `\nWczytuje WASM dla ${data.clientId}`;
                    workerPool.forEach(worker => {
                        worker.postMessage({ type: 'custom_wasm_available', data: data });
                    });
                });

                socket.on("unload_custom_wasm", (data) => {
                    if (data.targetWorkerIds && !data.targetWorkerIds.includes(myWorkerId)) {
                        return;
                    }
                    
                    workerPool.forEach(worker => {
                        worker.postMessage({ type: 'unload_custom_wasm', data: data });
                    });
                });

                socket.on("connect_error", (err) => {
                    console.error("[Main] Connection Error:", err.message);
                    statusDiv.textContent += `\nError w połączeniu - ${err.message}`;
                });

                socket.on("disconnect", (reason) => {
                    statusDiv.textContent += `\nOdłączono od serwera - ${reason}`;
                });
            }

        } else {
            document.body.innerHTML = '<h1>Przeglądarka nie obsługuje Web Workerów</h1>';
        }
    </script>
</body>

</html>
